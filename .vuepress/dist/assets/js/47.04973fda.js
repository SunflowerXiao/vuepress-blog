(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{506:function(t,a,s){"use strict";s.r(a);var r=s(19),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包"}},[t._v("#")]),t._v(" 什么是闭包")]),t._v(" "),s("ul",[s("li",[t._v("闭包是一个函数")]),t._v(" "),s("li",[t._v("闭包在函数内部访问了外部的变量")]),t._v(" "),s("li",[t._v("闭包的 VO 在执行前就会被创建， 这个时候他的 scope: [self.VO, parent.AO, go]")]),t._v(" "),s("li",[t._v("当外部函数执行完毕 parent.AO 被释放之后， 闭包的作用域链中 parent.AO 是没有被释放的，所以依旧可以调用外部的变量值")])]),t._v(" "),s("h2",{attrs:{id:"为什么要使用闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用闭包"}},[t._v("#")]),t._v(" 为什么要使用闭包")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("在没有 es6 模块化出来之前，使用闭包可以隔离作用域，进行模块化开发")])]),t._v(" "),s("li",[s("p",[t._v("函数的柯里化")])])]),t._v(" "),s("h2",{attrs:{id:"闭包的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的问题"}},[t._v("#")]),t._v(" 闭包的问题")]),t._v(" "),s("ul",[s("li",[t._v("导致内存泄漏： 因为作用域链的问题，他引用到的变量不会被释放，这样会导致内存泄漏")])]),t._v(" "),s("h3",{attrs:{id:"内存泄漏和内存溢出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏和内存溢出"}},[t._v("#")]),t._v(" 内存泄漏和内存溢出")]),t._v(" "),s("ul",[s("li",[t._v("内存泄漏是内存没有及时得到释放，内存泄漏可能会导致内存溢出")]),t._v(" "),s("li",[t._v("内存溢出就是指内存资源不够使用，如果内存溢出的话，程序是不能够继续正常运行的")])])])}),[],!1,null,null,null);a.default=e.exports}}]);