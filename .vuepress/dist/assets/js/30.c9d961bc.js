(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{486:function(t,a,r){"use strict";r.r(a);var s=r(19),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("ul",[r("li",[t._v("http 协议是超文本传输协议。")]),t._v(" "),r("li",[t._v("请求是无状态的。 协议对事务没有记忆能力， 如果后续处理需要之前的一些状态信息，就必须要重传。所以需要通过 cookie 和 session_id 来保存这个状态信息。")]),t._v(" "),r("li",[t._v("基于 TCP/IP 通信协议传递数据")])]),t._v(" "),r("h2",{attrs:{id:"http1-0"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http1-0"}},[t._v("#")]),t._v(" Http1.0")]),t._v(" "),r("ul",[r("li",[t._v("短连接")]),t._v(" "),r("li",[t._v("数据明文传输")]),t._v(" "),r("li",[t._v("头部协议不能压缩")])]),t._v(" "),r("h2",{attrs:{id:"http1-1"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" Http1.1")]),t._v(" "),r("h3",{attrs:{id:"文本传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文本传输"}},[t._v("#")]),t._v(" 文本传输")]),t._v(" "),r("p",[t._v("http1.1 的请求响应头和请求头信息都是明文的，并且是文本形式的")]),t._v(" "),r("p",[r("RouterLink",{attrs:{to:"/_posts/HTTP/header.html"}},[t._v("响应头信息")]),t._v(" "),r("RouterLink",{attrs:{to:"/_posts/HTTP/header.html"}},[t._v("消息头信息")])],1),t._v(" "),r("h3",{attrs:{id:"队头阻塞-并发请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队头阻塞-并发请求"}},[t._v("#")]),t._v(" 队头阻塞/ 并发请求")]),t._v(" "),r("ul",[r("li",[t._v("一个 TCP 连接一次只能发送一个请求，浏览器一次最多允许并行发送 6-8 个的 TCP 连接请求 （同一个域名下）")]),t._v(" "),r("li",[t._v("如果在一个 TCP 连接上的请求处理时间过长，就会造成队头阻塞")])]),t._v(" "),r("h2",{attrs:{id:"http2-0"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" Http2.0")]),t._v(" "),r("p",[t._v("建立一次 TCP/TP 连接，可以一次发送多个请求，请求内容以二进制的格式进行传输， 可能会产生丢包的现象")]),t._v(" "),r("h3",{attrs:{id:"二进制传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二进制传输"}},[t._v("#")]),t._v(" 二进制传输")]),t._v(" "),r("p",[t._v("frame 和帧")]),t._v(" "),r("p",[t._v("http2 中，同个域名下的所有通信都在单个连接上面完成，连接承载双向数据流。"),r("br"),t._v("\n数据流以消息的形式发送， 消息由一个或者多个帧组成，可能会被乱序发送。根据帧首部的标识可以重新组装")]),t._v(" "),r("h3",{attrs:{id:"多路复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),r("p",[t._v("不同于 http1.1 的并发请求控制， http2.0 同一个域名下面只需要发送一个 TCP 连接， 该连接可以同时发送多个 http 请求。"),r("br"),t._v("\n请求可以设置发送 的优先级")]),t._v(" "),r("h3",{attrs:{id:"压缩-headers-存储-header"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#压缩-headers-存储-header"}},[t._v("#")]),t._v(" 压缩 headers， 存储 header")]),t._v(" "),r("p",[t._v("HTTP/2 对消息头采用"),r("code",[t._v("HPACK")]),t._v("(专为 http/2 头部设计的压缩格式)进行压缩传输，能够节省消息头占用的网络的流量。")]),t._v(" "),r("h3",{attrs:{id:"首部表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#首部表"}},[t._v("#")]),t._v(" 首部表")]),t._v(" "),r("ul",[r("li",[t._v("HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的头部数据，不再通过每次请求和响应发送；")]),t._v(" "),r("li",[t._v("首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;")]),t._v(" "),r("li",[t._v("每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。")])]),t._v(" "),r("h3",{attrs:{id:"服务端推送"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送"}},[t._v("#")]),t._v(" 服务端推送")]),t._v(" "),r("p",[t._v("服务器可以在发送资源的时候，主动推送其他资源。而不用等到浏览器解析到对应位置主动再去发送一次请求"),r("br"),t._v("\n浏览器可以选择使用服务器主动推送的资源还是从缓存中读取资源")]),t._v(" "),r("h2",{attrs:{id:"http3-0"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http3-0"}},[t._v("#")]),t._v(" Http3.0")]),t._v(" "),r("h3",{attrs:{id:"基于-udp-的传输"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于-udp-的传输"}},[t._v("#")]),t._v(" 基于 UDP 的传输")])])}),[],!1,null,null,null);a.default=_.exports}}]);